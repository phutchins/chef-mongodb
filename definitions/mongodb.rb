#
# Cookbook Name:: mongodb
# Definition:: mongodb
#
# Copyright 2011, edelight GmbH
# Authors:
#       Markus Korn <markus.korn@edelight.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

define :mongodb_instance, :mongodb_type => "mongod" , :action => [:enable, :start],
    :bind_ip => nil, :port => 27017 , :logpath => "/var/log/mongodb",
    :dbpath => "/data", :configfile => "/etc/mongodb.conf", :configserver => [],
    :replicaset => nil, :maxconns => nil, :enable_rest => false, :notifies => [] do
    
  include_recipe "#{cookbook_name}::default"
  
  name = params[:name]
  type = params[:mongodb_type]
  service_action = params[:action]
  service_notifies = params[:notifies]
  
  bind_ip = params[:bind_ip]
  port = params[:port]

  logpath = params[:logpath]
  logfile = "#{logpath}/#{name}.log"

  maxconns = params[:maxconns]
  
  dbdir = params[:dbpath]
  dbpath = "#{dbdir}/#{name}"
  
  configfile = params[:configfile]
  configserver_nodes = params[:configserver]

  replicaset = params[:replicaset]

  if ["mongod", "shard", "configserver", "mongos"].include?(name)
    instance_name = "mongodb"
  elsif node[name].nil?
    instance_name = "mongodb"
  else
    instance_name = name
  end

  if type == "shard"
    if replicaset.nil?
      replicaset_name = nil
    else
      # Get the replicaset name that has either been manually set or generated by replset_namegen
      replicaset_name = replicaset[instance_name]['replicaset_name']
    end
  else
    # if there is a predefined replicaset name we use it,
    # otherwise we try to generate one using 'rs_$SHARD_NAME'
    begin
      replicaset_name = replicaset[instance_name]['replicaset_name']
    rescue
      replicaset_name = nil
    end
    if replicaset_name.nil?
      begin
        # shard_name has a default set so we can use that to generate a default replicaset name
        replicaset_name = "rs_" + replicaset[instance_name]['shard_name']
      rescue
        replicaset_name = nil
      end
    end
  end
  
  if !["mongod", "shard", "configserver", "mongos"].include?(type)
    raise "Unknown mongodb type '#{type}'"
  end

  if type != "mongos"
    daemon = "/usr/bin/mongod"
    configserver = nil
    configfile = nil
  else
    daemon = "/usr/bin/mongos"
    configfile = nil
    dbpath = nil
    configserver = configserver_nodes.collect{|n| "#{n['fqdn']}:" + n[instance_name]['port'] }.join(",")
  end
 
  
  # MongoDB Config file
  template "#{node['mongodb']['config_dir']}/#{name}.conf" do
    action :create
    source node["mongodb"]["config_template"]
    group node['mongodb']['root_group']
    owner "root"
    mode "0644"
    variables(
      "name" => name,
      "config" => configfile,
      "configdb" => configserver,
      "bind_ip" => bind_ip,
      "port" => port,
      "logpath" => logfile,
      "dbpath" => dbpath,
      "maxconns" => maxconns,
      "replicaset_name" => replicaset_name,
      "configsrv" => false, #type == "configserver", this might change the port
      "shardsrv" => false,  #type == "shard", dito.
      "enable_rest" => params["enable_rest"],
      "enable_fork" => params["enable_fork"]
    )
    cookbook "#{cookbook_name}"
    notifies :restart, "service[#{name}]"
  end

  template "#{node['mongodb']['upstart_config_dir']}/#{name}.conf" do
    action :create
    source node["mongodb"]["upstart_template"]
    group node['mongodb']['root_group']
    owner "root"
    mode "0644"
    variables(
      "name" => name,
      "user" => node["mongodb"]["user"],
      "daemon" => daemon
    )
    cookbook "#{cookbook_name}"
    notifies :restart, "service[#{name}]"
  end

  # service
  service name do
    provider Chef::Provider::Service::Upstart
    supports :status => true, :restart => true
    action service_action
    service_notifies.each do |service_notify|
      notifies :run, service_notify
    end
    #if !replicaset_name.nil?
    #  notifies :create, "ruby_block[config_replicaset]"
    #end
    #if type == "mongos"
    #  notifies :create, "ruby_block[config_sharding]"
    #end
  end
  
  # log dir [make sure it exists]
  directory logpath do
    owner node["mongodb"]["user"]
    group node["mongodb"]["group"]
    mode "0755"
    action :create
    recursive true
  end
  
  if type != "mongos"
    # dbpath dir [make sure it exists]
    directory dbpath do
      owner node["mongodb"]["user"]
      group node["mongodb"]["group"]
      mode "0755"
      action :create
      recursive true
    end
  end
  
  # replicaset
  if !node[instance_name]['type']['arbiter'].nil?
    Chef::Log.info("Node configured as an ARBITER")
  elsif !node[instance_name]['type']['hidden'].nil?
    Chef::Log.info("Node configured as a HIDDEN node")
  elsif !replicaset_name.nil?

    # Use ESPY to find nodes of the three types that go into the replicaset
    rs_nodes = []
    espy_rs_nodes = []

    Chef::Log.info("Site: #{node["site"]}")
    Chef::Log.info("Project: #{node["project"]}")
    Chef::Log.info("instance_name: #{instance_name}")
    advert = ["mongodb", node["site"], node["project"], instance_name].join("-")
    Chef::Log.info("Espy Search String: " + advert)

    if node['mongodb']['espy_search_orgs']
      nodes = espy(advert, orgs: node['mongodb']['espy_search_orgs'], fatal: false)
    else
      nodes = espy(advert, fatal: false)
    end
    if (nodes.length > 0) then
      Chef::Log.info("Espy Search Results: " + nodes.inspect)        
      nodes.each do |n|
        new_node = {}
        new_node["fqdn"] = n["fqdn"]
        new_node[instance_name] = { "port" => n["port"] }
        new_node[instance_name]["type"] = {}
        if !n["priority"].nil? then new_node[instance_name]["priority"] = n["priority"] end
        ["replicaset", "arbiter", "hidden"].each do |type|
          if !n[type].nil? then new_node[instance_name]["type"][type] = true end
        end
        espy_rs_nodes << new_node
      end
      rs_nodes = espy_rs_nodes
      rs_nodes.uniq!
      rs_nodes.sort!{ |x,y| x["fqdn"] <=> y["fqdn"] }
    else
      Chef::Log.info("No nodes found with ESPY Search #{advert}")
    end


    # Configure the replicaset with the nodes that we found
    ruby_block "config_replicaset" do
      block do
        if not replicaset.nil?
          Chef::Log.info("Instance Name: #{instance_name}")
          Chef::Log.info("Replicaset Name: #{replicaset_name}")
          #Chef::Log.info("rs_nodes: #{rs_nodes}")
          MongoDB.configure_replicaset(replicaset, instance_name, replicaset_name, rs_nodes)
        end
      end
      #Setting this to run every time as it would only run before if the service was notified with a restart or status
      #and we dont want to have to restart mongo every time we need the replicaset to be reconfigured
      # action :nothing
    end
  end
  
  # sharding
  if type == "mongos"
    # add all shards
    # configure the sharded collections
    
    rs_nodes = []
    espy_rs_nodes = []

    Chef::Log.info("Site: #{node["site"]}")
    Chef::Log.info("Project: #{node["project"]}")
    Chef::Log.info("instance_name: #{instance_name}")
    advert = ["mongodb", node["site"], node["project"], instance_name, node[instance_name]["shard_name"]].join("-")
    Chef::Log.info("Espy Search String: " + advert)

    if node['mongodb']['espy_search_orgs']
      nodes = espy(advert, orgs: node['mongodb']['espy_search_orgs'], fatal: false)
    else
      nodes = espy(advert, fatal: false)
    end
    if (nodes.length > 0) then
      Chef::Log.info("Espy Search Results: " + nodes.inspect)
      nodes.each do |n|
        new_node = {}
        new_node["fqdn"] = n["fqdn"]
        new_node[instance_name] = { "port" => n["port"] }
        new_node[instance_name]["type"] = {}
        if !n["priority"].nil? then new_node[instance_name]["priority"] = n["priority"] end
        if !n[instance_name]["cluster_name"].nil? then new_node[instance_name]["cluster_name"] = n["cluster_name"] end
        if !n[instance_name]["shard_name"].nil? then new_node[instance_name]["shard_name"] = n["shard_name"] end
        ["replicaset", "arbiter", "hidden"].each do |type|
          if !n[type].nil? then new_node[instance_name]["type"][type] = true end
        end
        espy_rs_nodes << new_node
      end
      rs_nodes = espy_rs_nodes
      rs_nodes.uniq!
      rs_nodes.sort!{ |x,y| x["fqdn"] <=> y["fqdn"] }
    else
      Chef::Log.info("No nodes found with ESPY Search #{advert}")
    end
    
    ruby_block "config_sharding" do
      block do
        Chef::Log.info("Found Shard Nodes: #{shard_nodes}")
        Chef::Log.info("Instance Name: #{instance_name}")
        if type == "mongos"
          MongoDB.configure_shards(node, instance_name, shard_nodes)
          MongoDB.configure_sharded_collections(node, instance_name, node[instance_name]['sharded_collections'])
        end
      end
      #Setting this to run every time as it would only run before if the service was notified with a restart or status
      #and we dont want to have to restart mongo every time we need the shards to be configured
      #action :nothing
    end
  end
end

